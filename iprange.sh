#!/bin/sh

##--------------------------------------------------------------------75-##
# iprange - version 0.6
# generate, maintain, and query a database of ip addresses
# (C) 2003 Raymond Foulk
#
# this script generates an initial list of ip addresses based on the
# caller's arguments.  addresses are stored in a plain text database for
# later processing by other iprange-* scripts.
#
# this script reports a random ip address from the database generated by
# iprange-init and moves that address from the 'in' to the 'out' database.
# this eliminates the address from the drawing-pool while recording the
# fact that it has been previously drawn (and in which order).
##--------------------------------------------------------------------75-##

##--------------------------------------------------------------------75-##
## initialize global data
##--------------------------------------------------------------------75-##

range_db_in="iprange-in"
range_db_out="iprange-out"
range_db_tmp="iprange-tmp"

range_min=0
range_max=255
range_start=$range_min
range_stop=$range_min
range_coerce=$range_min
range_entries=0

range_a=$range_min
range_b=$range_min
range_c=$range_min
range_d=$range_min

range_a_start=$range_min
range_a_stop=$range_min
range_b_start=$range_min
range_b_stop=$range_min
range_c_start=$range_min
range_c_stop=$range_min
range_d_start=$range_min
range_d_stop=$range_min

##--------------------------------------------------------------------75-##
## show how to use this script
##--------------------------------------------------------------------75-##

function ip_range_usage {
  echo "usage: ./iprange <mode> [arguments]"
  echo
  echo "mode: init"
  echo "./iprange init <A>.<B>.<C>.<D>"
  echo
  echo "  where A, B, C, and D are IPv4 address range arguments of one of"
  echo "  three possible forms.  comma-delimited lists are not yet supported."
  echo
  echo "  nnn         single numeric value.  ex: '57' or '201'"
  echo "  nnn-mmm     dash-separated range of values.  ex: '30-40'"
  echo "  --          double-dash indicates all possible values"
  echo
  echo "  examples:"
  echo "  ./iprange init 192.168.100-104.--"
  echo "  ./iprange init 10.0-20.--.--"
  echo "  ./iprange init 172.16.--.1"
  echo
  echo "mode: next"
  echo "./iprange next"
  echo
  echo "  get a random ip address from the database generated by 'init'"
  echo
  echo "mode: reset"
  echo "./iprange reset"
  echo
  echo "  delete all entries in existing database"
  echo
}

##--------------------------------------------------------------------75-##
## show some values for debugging
##--------------------------------------------------------------------75-##

function ip_range_report {
  echo "ip_range_report:"
  echo
  echo "range_start: $range_start"
  echo "range_stop: $range_stop"
  echo "range_a_start: $range_a_start"
  echo "range_a_stop: $range_a_stop"
  echo "range_b_start: $range_b_start"
  echo "range_b_stop: $range_b_stop"
  echo "range_c_start: $range_c_start"
  echo "range_c_stop: $range_c_stop"
  echo "range_d_start: $range_d_start"
  echo "range_d_stop: $range_d_stop"
  echo
  #echo "range_entries: $range_entries"
  #echo
}

##--------------------------------------------------------------------75-##
## keep numeric arguments bounded
##--------------------------------------------------------------------75-##

function ip_range_coerce {
  # set default range if no arguments
  if [ -z $1 ]
  then
    echo "warning: ip_range_coerce: no range coerce argument"
    range_coerce=0
  else
    range_coerce=$1
  fi

  # coerce the value to within acceptible bounds
  if [ $range_coerce -lt $range_min ]
  then
    range_coerce=$range_min
  elif [ $range_coerce -gt $range_max ]
  then
    range_coerce=$range_max
  fi
}

##--------------------------------------------------------------------75-##
## interpret a single address range value
##--------------------------------------------------------------------75-##

function ip_range_interp {
  # set default range if no arguments
  if [ -z "$1" ]
  then
    echo "warning: ip_range_interp: no range argument"
    range="0"
  else
    range="$1"
  fi

  # check for range wildcard '*'
  # update - use '--' for wildcard since bash is finicky about '*'
  # note that '---' would work too since it includes '--'
  #if ( echo "$range" | grep "*" > /dev/null )
  if ( echo "$range" | grep "\-\-" > /dev/null )
  then
    range_start=$range_min
    range_stop=$range_max

  # check for dash-separated range
  elif ( echo "$range" | grep "-" > /dev/null )
  then
    range_start=`echo $range | cut -d'-' --fields=1`
    ip_range_coerce $range_start
    range_start=$range_coerce

    range_stop=`echo $range | cut -d'-' --fields=2`
    ip_range_coerce $range_stop
    range_stop=$range_coerce

  # assume singular value by default
  else
    ip_range_coerce $range
    range_start=$range
    range_stop=$range
  fi
}

##--------------------------------------------------------------------75-##
## split the caller's address range into 4 parts
##--------------------------------------------------------------------75-##

function ip_range_parse {
  # set default address if no arguments
  if [ -z "$1" ]
  then
    echo "warning: ip_range_split: no address range argument"
    range_address="0.0.0.0"
  else
    range_address="$1"
  fi

  # break address range into class arguments
  range_a=`echo "$range_address" | cut -d'.' --fields=1`
  range_b=`echo "$range_address" | cut -d'.' --fields=2`
  range_c=`echo "$range_address" | cut -d'.' --fields=3`
  range_d=`echo "$range_address" | cut -d'.' --fields=4`     

  # get start/stop for each class
  ip_range_interp $range_a
  range_a_start=$range_start
  range_a_stop=$range_stop

  ip_range_interp $range_b
  range_b_start=$range_start
  range_b_stop=$range_stop

  ip_range_interp $range_c
  range_c_start=$range_start
  range_c_stop=$range_stop

  ip_range_interp $range_d
  range_d_start=$range_start
  range_d_stop=$range_stop
}

##--------------------------------------------------------------------75-##
## erase and reset existing database
##--------------------------------------------------------------------75-##

function ip_range_reset {
  # clobber database files nicely
  if [ -e "$range_db_in" ]
  then
    rm -f "$range_db_in"
  fi

  if [ -e "$range_db_out" ]
  then
    rm -f "$range_db_out"
  fi

  touch "$range_db_in"
  touch "$range_db_out"
}

##--------------------------------------------------------------------75-##
## generate the ordered ip address database
##--------------------------------------------------------------------75-##

function ip_range_generate {
  local loop_a=$range_a_start
  local loop_b=$range_b_start
  local loop_c=$range_c_start
  local loop_d=$range_d_start

  # generate ip address input database
  while [ ! "$loop_a" -gt $range_a_stop ]
  do                                                  
    while [ ! "$loop_b" -gt $range_b_stop ]
    do                                                  
      while [ ! "$loop_c" -gt $range_c_stop ]
      do                                                  
        while [ ! "$loop_d" -gt $range_d_stop ]
        do
          address="$loop_a.$loop_b.$loop_c.$loop_d"
          echo "$address" >> "$range_db_in"
          loop_d=$[$loop_d+1]
        done
        loop_c=$[$loop_c+1]
        loop_d=$range_d_start
      done
      loop_b=$[$loop_b+1]
      loop_c=$range_c_start
    done
    loop_a=$[$loop_a+1]
    loop_b=$range_b_start
  done
}

##--------------------------------------------------------------------75-##
## draw and delete a random record from the address database
##--------------------------------------------------------------------75-##

function ip_range_next {
  # check for existance of input database file
  if [ ! -e "$range_db_in" ]
  then
    echo "error: $range_db_in does not exist"
  else
    # get number of lines in database file
    range_entries=`wc -l "$range_db_in" | sed -e 's/^[ ^t]*//g' | \
      cut --delimiter=' ' --fields=1`

    # check for empty database
    if [ $range_entries -eq 0 ]
    then
      echo "error: address database is empty"
    else
      # generate a random line number
      range_random=$RANDOM
      #let "range_random %= $range_entries"
      range_random=$[$range_random%$range_entries]
      range_random=$[$range_random+1]

      # get and remove the address at the specified line
      address=`sed -n "$range_random p" "$range_db_in"`
      sed "$range_random d" "$range_db_in" > "$range_db_tmp"
      mv -f "$range_db_tmp" "$range_db_in"
      # note - this is disk i/o intensive!! :(

      # report address and record to output database
      echo "$address"
      echo "$address" >> "$range_db_out"
      #echo "range_entries: $range_entries"
      #echo "range_random: $range_random"
    fi
  fi
}

##--------------------------------------------------------------------75-##
## get mode argument and perform appropriate calls
##--------------------------------------------------------------------75-##

function ip_range_main {
  # show help if no mode argument
  if [ -z "$1" ]
  then
    ip_range_usage

  #########################
  elif [ "$1" == "init" ]
  then
    ip_range_parse "$2"
    ip_range_report
    ip_range_reset
    ip_range_generate

  #########################
  elif [ "$1" == "next" ]
  then
    ip_range_next

  #########################
  elif [ "$1" == "reset" ]
  then
    ip_range_reset

  #########################
  else
    echo "error: unknown mode: $1"
  fi
}

##--------------------------------------------------------------------75-##
## run the script with arguments
##--------------------------------------------------------------------75-##

ip_range_main $*
